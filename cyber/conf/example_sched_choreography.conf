# choreography 策略,主要是对主链路上的任务进行编排（choreography开头的配置）,将非主链路的任务放到线程池中由 classic 策略（pool开头的配置）执行,
# choreography 策略中 classic 线程池存在的意义：
## 主链路的任务执行先后关系比较明确,但是存在一些其他链路的任务在不清楚前后拓扑关系的情况下,
## 或者说未被编排的任务（包括Async创建的异步task）,会被放到 classic 线程池中执行
scheduler_conf {
    policy: "choreography"
    process_level_cpuset: "0-7,16-23"  # all threads in the process are on the cpuset
    threads: [
        {
            name: "lidar"
            cpuset: "1"
            policy: "SCHED_RR" # policy: SCHED_OTHER,SCHED_RR,SCHED_FIFO
            prio: 10
        }, {
            name: "shm"
            cpuset: "2"
            policy: "SCHED_FIFO"
            prio: 10
        }
    ]
    choreography_conf {
        choreography_processor_num: 8
        choreography_affinity: "range"
        choreography_cpuset: "0-7"
        # 设置编排线程的调度策略和优先级,这里设置SCHED_FIFO是为了保证主链路能够及时抢占cpu执行
        choreography_processor_policy: "SCHED_FIFO" # policy: SCHED_OTHER,SCHED_RR,SCHED_FIFO
        choreography_processor_prio: 10

        pool_processor_num: 8
        pool_affinity: "range"
        pool_cpuset: "16-23"
        # 设置 classic 线程的调度策略和优先级
        pool_processor_policy: "SCHED_OTHER"
        pool_processor_prio: 0

        # 同一个path的任务尽量编排在同一个processor,如果processor负载过高,将部分任务拆分到另外其他processor
        # 同一个path上的任务从开始到结束,优先级逐级升高
        # 不同path上的任务尽量不混排
        # 高频&短耗时任务尽量排放同一processor
        tasks: [
            {
                name: "A"
                processor: 0 # 主链路任务,都设置了 processor 属性
                prio: 1
            },
            {
                name: "B"
                processor: 0 # 主链路任务,都设置了 processor 属性
                prio: 2
            },
            {
                name: "C"
                processor: 1 # 主链路任务,都设置了 processor 属性
                prio: 1
            },
            {
                name: "D"
                processor: 1 # 主链路任务,都设置了 processor 属性
                prio: 2
            },
            {
                name: "E"    # 没有配置 processor 属性,则默认进入 classic 线程池中执行
            }
        ]
    }
}
